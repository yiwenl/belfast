import "../scss/global.scss";

import { GL, GLTool, GLShader, Mesh } from "../../src/alfrid";
import { vec3, mat4 } from "gl-matrix";
const canvas1 = document.createElement("canvas");
const canvas2 = document.createElement("canvas");

import vs from "../shaders/test.vert";
import fs from "../shaders/test.frag";

GL.init(canvas1);
GL.setSize(window.innerWidth / 2, window.innerHeight);

const contextLostTest = false;
if (contextLostTest) {
  GL.on(GL.CONTEXT_LOST, () => {
    console.log("WebGL Context Lost");
  });

  setTimeout(() => {
    console.log("Destroy context");
    GL.destroy();
  }, 2000);
}

const GL2 = new GLTool();
const ctx2 = canvas2.getContext("webgl");
GL2.init(ctx2);
GL2.setSize(window.innerWidth / 2, window.innerHeight);
console.log(GL);

/*
// log WebGL Context native methods
const regex = RegExp("[a-z]");
for (let s in GL.gl) {
  const firtChar = s.substring(0, 1);
  if (regex.test(firtChar)) {
    console.log(s);
  }
}
*/
document.body.appendChild(canvas1);
document.body.appendChild(canvas2);

let g = 0.1;
// GL.clear(1, 0, 0, g);
// GL2.clear(0, 1, 0, g);

GL.clear(g, 0, 0, 1);
GL2.clear(0, g, 0, 1);

const draw1 = true;
const shader = new GLShader(vs, fs);
console.log(shader);
const mesh = new Mesh();
console.log(mesh);

let s = 0.5;
// const positions = [[0, s, 0], [-s, -s / 2, 0], [s, -s / 2, 0]];
const positions = [
  vec3.fromValues(0, s, 0),
  vec3.fromValues(-s, -s / 2, 0),
  vec3.fromValues(s, -s / 2, 0),
];
// const colors = [[1, 0, 0], [0, 1, 0], [0, 0, 1]].flat();
const colors = [[0, 0, 0], [1, 1, 0], [2, 0, 1]];
const indices = [0, 1, 2];

mesh
  .bufferVertex(positions)
  .bufferData(colors, "aColor")
  .bufferIndex(indices);

// uniforms

g = 0.5;
const _colors = [[1, g, g], [g, 1, g], [g, g, 1]].flat();

const mtx = mat4.create();
// mat4.translate(mtx, mtx, [0.5, 0, 0]);

const mtxView = mat4.create();
const mtxProj = mat4.create();

mat4.perspective(mtxProj, Math.PI / 2, GL.getAspectRatio(), 0.1, 100);
mat4.lookAt(mtxView, [0, 0, 5], [0, 0, 0], [0, 1, 0]);

// shader.uniform("uColor", "vec3", [1, 0, 0]);
shader.uniform("uColors", "vec3", _colors);
shader.uniform("uModelMatrix", mtx);
shader.uniform("uProjectionMatrix", mtxProj);
shader.uniform("uViewMatrix", mtxView);

/*
 * Shader and Mesh ( buffers ) won't be created until they are going to be bind
 * They'll be generated by the WebGL context that it binds or draws
 */
if (draw1) {
  shader.bind();
  GL.draw(mesh);
} else {
  shader.bind(GL2);
  GL2.draw(mesh);
}

// resize
window.addEventListener("resize", resize);

function resize() {
  GL.setSize(window.innerWidth / 2, window.innerHeight);
  GL2.setSize(window.innerWidth / 2, window.innerHeight);
}
